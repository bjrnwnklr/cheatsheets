<!DOCTYPE html>
    <html>
    <head>
        <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
        <title>Advent of code - cheatsheet</title>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.css" integrity="sha384-9eLZqc9ds8eNjO3TmqPeYcDj8n+Qfa4nuSiGYa6DjLNcv9BtN69ZIulL9+8CqC9Y" crossorigin="anonymous">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
        <link href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css" rel="stylesheet" type="text/css">
        <style>
.task-list-item { list-style-type: none; } .task-list-item-checkbox { margin-left: -20px; vertical-align: middle; }
</style>
        <style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', 'HelveticaNeue-Light', 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1;
            }
        </style>
        
        <script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script>
    </head>
    <body>
        <h1 id="advent-of-code---cheatsheet">Advent of code - cheatsheet</h1>
<p>Some cool tricks learned from Advent Of Code 2018</p>
<ul>
<li><a href="#advent-of-code---cheatsheet">Advent of code - cheatsheet</a>
<ul>
<li><a href="#1-decoding-some-lines-from-input-file">1. Decoding some lines from input file</a></li>
<li><a href="#2-splitting-input-into-a-list-of-tuples-and-converting-to-int-at-the-same-time">2. Splitting input into a list of tuples and converting to int at the same time</a></li>
<li><a href="#2-using-regex-to-find-data-in-input-file-and-converting-to-timestamp">2. Using regex to find data in input file and converting to timestamp</a></li>
<li><a href="#3-sorting-a-dictionary">3. sorting a dictionary</a></li>
<li><a href="#4-finding-maximum-value-key-in-a-dictionary">4. finding maximum value /key in a dictionary</a></li>
<li><a href="#5-finding-maximum-from-a-dictionary-with-tuple-as-key">5. finding maximum from a dictionary with tuple as key</a></li>
<li><a href="#6-list-comprehension-with-3-loops">6. List comprehension with 3 loops</a></li>
<li><a href="#advent-of-code-2018-day-11">Advent of code 2018, day 11</a>
<ul>
<li><a href="#using-a-partial-sum-table-to-calculate-sums-across-a-2d-grid">Using a partial sum table to calculate sums across a 2D grid</a></li>
</ul>
</li>
<li><a href="#advent-of-code-2018-day-12">Advent of code 2018, day 12</a>
<ul>
<li><a href="#using-regex-to-find-all-lines-that-contain--and">using regex to find all lines that contain '.' and '#'</a></li>
</ul>
</li>
<li><a href="#advent-of-code-2018-day-13">Advent of code 2018, day 13</a>
<ul>
<li><a href="#sorting-a-list-of-objects-by-tuple-of-object-attributes">sorting a list of objects by tuple of object attributes</a></li>
</ul>
</li>
<li><a href="#advent-of-code-2018-day-20">Advent of code 2018, day 20</a>
<ul>
<li><a href="#parsing-a-regex-like-input-string-with-branches-and-options">Parsing a regex like input string with branches and options</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="1-decoding-some-lines-from-input-file">1. Decoding some lines from input file</h2>
<p>Lines look like</p>
<pre><code>#1 @ 1,3: 4x4
#2 @ 3,1: 4x4
#3 @ 5,5: 2x2
</code></pre>
<pre><code class="language-python"><div><span class="hljs-comment"># regex to find all numbers (\d) with 1 or more digits (+)</span>
<span class="hljs-comment"># map converts them to int tuples</span>
<span class="hljs-comment"># * unpacks the output</span>
<span class="hljs-keyword">import</span> re

input_file = open(<span class="hljs-string">r'filename.txt'</span>, <span class="hljs-string">'r'</span>)

claims = [[*map(int, re.findall(<span class="hljs-string">r'\d+'</span>, l))] <span class="hljs-keyword">for</span> l <span class="hljs-keyword">in</span> input_file.splitlines() <span class="hljs-keyword">if</span> l]
</div></code></pre>
<h2 id="2-splitting-input-into-a-list-of-tuples-and-converting-to-int-at-the-same-time">2. Splitting input into a list of tuples and converting to int at the same time</h2>
<p>Input looks like:</p>
<pre><code>77, 83
345, 79
</code></pre>
<pre><code class="language-python"><div>coordinates_str = [tuple(map(int, line.split(<span class="hljs-string">','</span>))) <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> input_file]
</div></code></pre>
<h2 id="2-using-regex-to-find-data-in-input-file-and-converting-to-timestamp">2. Using regex to find data in input file and converting to timestamp</h2>
<p>input lines look like</p>
<pre><code>[1518-05-24 23:56] Guard #1721 begins shift
[1518-08-22 00:09] falls asleep
</code></pre>
<pre><code class="language-python"><div><span class="hljs-comment"># () in regex save results as 'groups' - can be accessed by .group(n) argument</span>
one_line = re.search(<span class="hljs-string">r'\[(.+)\]\s(\w+)\s(.+)'</span>, data_input[<span class="hljs-number">0</span>])
<span class="hljs-comment"># datetime.fromisoformat(string) converts timestamp in yyyy-mm-dd hh:mm format</span>
timestamp = datetime.fromisoformat(one_line.group(<span class="hljs-number">1</span>))
</div></code></pre>
<h2 id="3-sorting-a-dictionary">3. sorting a dictionary</h2>
<p><code>event_list</code> is a list of dictionaries, <code>keys</code> is a list of strings that represent key names
<code>values</code> is a list of values</p>
<pre><code class="language-python"><div><span class="hljs-comment"># append a new dictionary made of keys and values</span>
event_list.append(dict(zip(keys, values)))
<span class="hljs-comment"># sort the list of dictionaries using the 'timestamp' entry of each dictionary</span>
sorted_events = sorted(event_list, key=<span class="hljs-keyword">lambda</span> event_entry: event_entry[<span class="hljs-string">'timestamp'</span>])
</div></code></pre>
<h2 id="4-finding-maximum-value-key-in-a-dictionary">4. finding maximum value /key in a dictionary</h2>
<p>Find the key for the maximum value in a dictionary - similar to the sorting above</p>
<pre><code class="language-python"><div>k = max(dictionary, key = <span class="hljs-keyword">lambda</span> k: dictionary[k])
</div></code></pre>
<h2 id="5-finding-maximum-from-a-dictionary-with-tuple-as-key">5. finding maximum from a dictionary with tuple as key</h2>
<p>Find the key for the maximum value in a dictionary with a ('string', int) tuple as key, like</p>
<pre><code>dictionary[('2879', 49)] = 21
</code></pre>
<pre><code class="language-python"><div>best_key1, best_key2 = max(dictionary, key = dictionary.get)
</div></code></pre>
<h2 id="6-list-comprehension-with-3-loops">6. List comprehension with 3 loops</h2>
<pre><code class="language-python"><div><span class="hljs-comment"># creates tuples (0, 0, 0) to (10, 10, 10)</span>
test_squares = [(i, j, k) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>) <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>) <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>)]
</div></code></pre>
<h2 id="advent-of-code-2018-day-11">Advent of code 2018, day 11</h2>
<h3 id="using-a-partial-sum-table-to-calculate-sums-across-a-2d-grid">Using a partial sum table to calculate sums across a 2D grid</h3>
<pre><code class="language-python"><div><span class="hljs-comment"># create partial sums</span>
<span class="hljs-comment"># A B C</span>
<span class="hljs-comment"># D E F</span>
<span class="hljs-comment"># G H I</span>
<span class="hljs-comment"># partial sum for I =</span>
<span class="hljs-comment"># H + F + f(I) - E</span>
<span class="hljs-comment"># (x-1, y) + (x, y-1) + f(I) - (x-1, y-1)</span>
<span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">300</span>):
    <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> range(<span class="hljs-number">300</span>):
        part_sum[x][y] = get_part_sum(x<span class="hljs-number">-1</span>, y) + get_part_sum(x, y<span class="hljs-number">-1</span>) + grid[x][y] - get_part_sum(x<span class="hljs-number">-1</span>, y<span class="hljs-number">-1</span>)
</div></code></pre>
<h2 id="advent-of-code-2018-day-12">Advent of code 2018, day 12</h2>
<h3 id="using-regex-to-find-all-lines-that-contain--and">using regex to find all lines that contain '.' and '#'</h3>
<p>Input looked like this:</p>
<pre><code><div>initial state: #.##.###.#.##...##..#..##....#.#.#.#.##....##..#..####..###.####.##.#..#...#..######.#.....#..##...#

.#.#. =&gt; .
...#. =&gt; #
..##. =&gt; .
....# =&gt; .
##.#. =&gt; #
</div></code></pre>
<pre><code class="language-python"><div><span class="hljs-keyword">import</span> re
<span class="hljs-comment"># 'text' is the input file</span>
initial, *pairs = re.findall(<span class="hljs-string">r'[.#]+'</span>, text)
<span class="hljs-comment"># feeds the first line into 'initial' and the rest of the lines into a list 'pairs'</span>
</div></code></pre>
<h2 id="advent-of-code-2018-day-13">Advent of code 2018, day 13</h2>
<h3 id="sorting-a-list-of-objects-by-tuple-of-object-attributes">sorting a list of objects by tuple of object attributes</h3>
<pre><code class="language-python"><div><span class="hljs-comment"># cr.r = row index</span>
<span class="hljs-comment"># cr.c = column index</span>
<span class="hljs-comment"># we want to sort by lowest row first, then lowest column second</span>
<span class="hljs-comment"># this works with tuples</span>
carts = sorted(carts, key= <span class="hljs-keyword">lambda</span> cr: (cr.r, cr.c))
</div></code></pre>
<h2 id="advent-of-code-2018-day-20">Advent of code 2018, day 20</h2>
<h3 id="parsing-a-regex-like-input-string-with-branches-and-options">Parsing a regex like input string with branches and options</h3>
<ul>
<li><code>'('</code> starts a branch, <code>'|'</code> is a divider between options, <code>')'</code> closes a branch</li>
<li>parse through the input string and remember positions when encountering a branch - by using a stack</li>
</ul>
<pre><code class="language-python"><div><span class="hljs-comment"># directions</span>
directions = {
                <span class="hljs-string">'N'</span>: (<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>),
                <span class="hljs-string">'E'</span>: (<span class="hljs-number">1</span>, <span class="hljs-number">0</span>),
                <span class="hljs-string">'S'</span>: (<span class="hljs-number">0</span>, <span class="hljs-number">1</span>),
                <span class="hljs-string">'W'</span>: (<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>)
}

<span class="hljs-comment"># stack to track current position</span>
positions = []
<span class="hljs-comment"># starting positions</span>
x, y = <span class="hljs-number">5000</span>, <span class="hljs-number">5000</span>
<span class="hljs-comment"># previous positions</span>
pre_x, pre_y = x, y
<span class="hljs-comment"># distance tracking dictionary</span>
distances = defaultdict(int)
<span class="hljs-comment"># starting distance</span>
dist = <span class="hljs-number">0</span>

<span class="hljs-comment">########## set input</span>
f = open(<span class="hljs-string">r'input.txt'</span>).read().rstrip()
maze = f

<span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> maze[<span class="hljs-number">1</span>:<span class="hljs-number">-1</span>]:
    print(<span class="hljs-string">'Char: %s, stack: %d'</span> % (c, len(positions)))
    <span class="hljs-keyword">if</span> c == <span class="hljs-string">'('</span>:   <span class="hljs-comment"># save position if we find a new branch</span>
        positions.append((x, y))
    <span class="hljs-keyword">elif</span> c == <span class="hljs-string">')'</span>: <span class="hljs-comment"># end of branch, pop position before branch</span>
        x, y = positions.pop()
    <span class="hljs-keyword">elif</span> c == <span class="hljs-string">'|'</span>: <span class="hljs-comment"># option, go back to last position but leave on stack</span>
                   <span class="hljs-comment"># until we find the closing ')'</span>
        x, y = positions[<span class="hljs-number">-1</span>]
    <span class="hljs-keyword">else</span>:          <span class="hljs-comment"># process door</span>
        dx, dy = directions[c] <span class="hljs-comment"># get direction change</span>
        x += dx
        y += dy
        <span class="hljs-comment"># add to distance (distance for current position)</span>
        <span class="hljs-keyword">if</span> distances[(x, y)] != <span class="hljs-number">0</span>:  <span class="hljs-comment"># we already have a distance entry - we were here already</span>
            <span class="hljs-comment"># take the minimum since there is a shorter route to the room</span>
            distances[(x, y)] = min(distances[(x, y)], distances[(pre_x, pre_y)] + <span class="hljs-number">1</span>)
        <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># new room, add previous distance plus 1</span>
            distances[(x, y)] = distances[(pre_x, pre_y)] + <span class="hljs-number">1</span>

    pre_x, pre_y = x, y
</div></code></pre>

    </body>
    </html>